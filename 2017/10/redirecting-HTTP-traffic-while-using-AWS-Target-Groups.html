<!doctype html>
<html lang="en">

<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>  Redirecting HTTP traffic while using AWS Target Groups | Nairobi GNU/Linux Users Group
</title>
  <link rel="canonical" href="/2017/10/redirecting-HTTP-traffic-while-using-AWS-Target-Groups.html">

    <link rel="apple-touch-icon" href="/apple-touch-icon.png" sizes="180x180">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#333333">

  <link rel="stylesheet" href="/theme/css/bootstrap.min.css">
  <link rel="stylesheet" href="/theme/css/fontawesome.min.css">
  <link rel="stylesheet" href="/theme/css/pygments/monokai.min.css">
  <link rel="stylesheet" href="/theme/css/theme.css">

  
  <meta name="description" content="How to use HSTS and NGINX to redirect HTTP to HTTPS while behind AWS's Elastic Load Balancer and Target Groups.">


</head>

<body>
  <header class="header">
    <div class="container">
<div class="row">
    <div class="col-sm-4">
      <a href="/">
        <img class="img-fluid rounded" src=/images/profile.png alt="Nairobi GNU/Linux Users Group">
      </a>
    </div>
  <div class="col-sm-8">
    <h1 class="title"><a href="/">Nairobi GNU/Linux Users Group</a></h1>
      <p class="text-muted">A lively community of GNU/Linux enthusiasts</p>
      <ul class="list-inline">
          <li class="list-inline-item"><a href="https://web.libera.chat/?channels=#nairobilug" target="_blank">IRC</a></li>
              <li class="list-inline-item text-muted">|</li>
            <li class="list-inline-item"><a href="/pages/about-us.html">About Us</a></li>
            <li class="list-inline-item"><a href="/pages/code-of-conduct.html">Code of Conduct</a></li>
            <li class="list-inline-item"><a href="/pages/contact.html">Contact</a></li>
            <li class="list-inline-item"><a href="/pages/mailing-list.html">Mailing List</a></li>
            <li class="list-inline-item"><a href="/pages/meetups.html">Meetups</a></li>
            <li class="list-inline-item"><a href="/pages/software.html">Software</a></li>
            <li class=" list-inline-item text-muted">|</li>
          <li class="list-inline-item"><a class="fab fa-github" href="https://github.com/nairobilug" target="_blank"></a></li>
          <li class="list-inline-item"><a class="fab fa-twitter" href="https://twitter.com/nairobilug" target="_blank"></a></li>
      </ul>
  </div>
</div>    </div>
  </header>

  <div class="main">
    <div class="container">
      <h1>  Redirecting HTTP traffic while using AWS Target Groups
</h1>
      <hr>
  <article class="article">
    <header>
      <ul class="list-inline">
        <li class="list-inline-item text-muted" title="2017-10-04T10:38:00+03:00">
          <i class="fas fa-clock"></i>
          Wed 04 October 2017
        </li>
        <li class="list-inline-item">
          <i class="fas fa-folder-open"></i>
          <a href="/category/aws.html">AWS</a>
        </li>
          <li class="list-inline-item">
            <i class="fas fa-user"></i>
              <a href="/author/njagi-mwaniki.html">Njagi Mwaniki</a>          </li>
          <li class="list-inline-item">
            <i class="fas fa-tag"></i>
              <a href="/tag/linux.html">#linux</a>,               <a href="/tag/devops.html">#devops</a>,               <a href="/tag/hsts.html">#hsts</a>          </li>
      </ul>
    </header>
    <div class="content">
      <p>Originally posted <a href="https://blog.ona.io/devops/2017/03/31/Redirecting-http-traffic-while-using-aws-target-groups.html">on the ona.io blog</a>.</p>
<p>A few months ago we received a support query from a user who was unable to
log in. We couldn't replicate the issue and they weren't able to work with
us to get it fixed.
We concluded that they were doing something unique and had ended up fixing it
from their end somehow.</p>
<p>Fast forward to March 5th, when we sent email invitations for a
<a href="https://nairobilug.org/">Nairobi Linux Users Group</a> meet-up with an HTTP&mdash;not HTTPS&mdash;link to the login
page, <code>http://ona.io/login</code>, and got a complaint that the site did not redirect
to HTTPS on the <code>/login</code> or <code>/join</code> routes. This was a serious problem because we only perform sign-ups, log-ins or any
other form of data exchange over HTTPS, including setting cookies.</p>
<p>When we find the user's authentication cookies are not set, or are expired, we
reload the page so that they can get a new authentication cookie.
We implemented this as shown below, by checking for a 401 status from the <a href="http://github.com/onaio/onadata">OnaData API</a>. More of that code is <a href="https://github.com/onaio/milia/blob/580969b2b2a88a446b5d903237adca7ab4003096/src/milia/api/io.cljs#L119">here</a>.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="kd">defn </span><span class="nv">http-request</span>
<span class="w">  </span><span class="s">&quot;Wraps cljs-http.client/request and redirects if status is 401&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">request-fn</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">response-channel</span><span class="w"> </span><span class="p">(</span><span class="nf">chan</span><span class="p">)]</span>
<span class="w">    </span><span class="p">(</span><span class="nf">go</span>
<span class="w">      </span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">original-response-channel</span><span class="w"> </span><span class="p">(</span><span class="nf">apply</span><span class="w"> </span><span class="nv">request-fn</span><span class="w"> </span><span class="nv">args</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span><span class="ss">:keys</span><span class="w"> </span><span class="p">[</span><span class="nv">status</span><span class="p">]</span><span class="w"> </span><span class="ss">:as</span><span class="w"> </span><span class="nv">response</span><span class="p">}</span><span class="w"> </span><span class="p">(</span><span class="nf">&lt;!</span><span class="w"> </span><span class="nv">original-response-channel</span><span class="p">)]</span>
<span class="w">        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">=</span><span class="w"> </span><span class="nv">status</span><span class="w"> </span><span class="mi">401</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">set</span><span class="nv">!</span><span class="w"> </span><span class="nv">js/window.location</span><span class="w"> </span><span class="p">(</span><span class="nf">.href</span><span class="w"> </span><span class="nv">js/window.location</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="nf">put!</span><span class="w"> </span><span class="nv">response-channel</span><span class="w"> </span><span class="nv">response</span><span class="p">))))</span>
<span class="nv">response-channel</span><span class="p">))</span>
</code></pre></div>

<p>As a consequence of this setup, when a user connects over HTTP and is not redirected
to HTTPS they can end up in an endless loop of reloads when they try to sign-up,
log-in or submit data in any other way.
When we tried it ourselves, HTTP redirected to HTTPS just fine. However, we
noticed that it didn't redirect on a fresh Firefox install, assuming this fresh
install didn't have add-ons like <a href="https://www.eff.org/HTTPS-Everywhere">HTTPS Everywhere</a>.</p>
<!-- more -->

<h2>Narrowing down the problem</h2>
<p>Now that we had verified there was a problem, we had to figure out why it didn't happen anywhere else, why we hadn't noticed it before, and why it only happened on fresh Firefox installs.</p>
<h4>Enter <a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security">HSTS</a></h4>
<p><a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security">From Wikipedia</a>:
"HTTP Strict Transport Security (HSTS) is a web security policy
mechanism which helps to protect websites against protocol downgrade attacks and
cookie hijacking."</p>
<p>We already included the HSTS header in our responses. If you use an HSTS-enabled
website over HTTPS your browser saves the HSTS header and uses HTTPS in future
requests.</p>
<p>With our broken setup, if you visited the root site itself over HTTP, <code>http://ona.io</code>, it properly redirected to
HTTPS. Your browser would take note of the HSTS
header, save it, and redirect to HTTPS for other <code>ona.io</code> routes, e.g.
<code>http://ona.io/login</code> and <code>http://ona.io/join</code> would be redirect to <code>https://ona.io/login</code> and <code>https://ona.io/join</code>, respectively. However, if you had never visited Ona, and your first visit was to a non-root HTTP URL, e.g. <code>http://ona.io/login</code>, the HSTS header would not be set, your cookie would not be set and you'd end up in a redirect loop. This is why we only saw the problem with fresh browser installs and non-root HTTP URLs.</p>
<h2>Digging deeper</h2>
<p>Next, we noticed that the domain names that weren't using AWS Target Groups redirected to
HTTPS just fine and those that did use AWS Target Groups were not redirecting.
With AWS Target Groups being the common factor, we assumed they were the cause and
looked for more evidence.</p>
<h4>What are AWS Target Groups and why use them?</h4>
<p>AWS Target Groups are a way to route different requests to different servers
based on the load balancer they are attached to and the requested path. For the new AWS Elastic Load Balancers, Target Groups are the standard (and only) way to connect servers to a route. In our setup, they let us send traffic to either the API servers or the UI servers depending on what path you request for the same domain. Target Groups have their own health checks, similar to the health checks on Classic AWS Elastic Load Balancers, and if a Target Group fails its health checks Elastic Load Balancer traffic will not be routed to it. Refer to the <a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html">AWS Target Groups documentation</a> for more on this.</p>
<h4>HTTPS traffic</h4>
<p>As you can see below, we had no problem handling HTTPS traffic with our setup. We responded with a <code>200 OK</code> as
intended.</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>curl<span class="w"> </span>--head<span class="w"> </span>-X<span class="w"> </span>GET<span class="w"> </span><span class="s2">&quot;https://ona.io/login&quot;</span>
HTTP/1.1<span class="w"> </span><span class="m">200</span><span class="w"> </span>OK
Set-Cookie:<span class="w"> </span><span class="nv">AWSALB</span><span class="o">=</span>PqCh/O<span class="p">;</span><span class="w"> </span><span class="nv">Expires</span><span class="o">=</span>Thu,<span class="w"> </span><span class="m">23</span><span class="w"> </span>Mar<span class="w"> </span><span class="m">2017</span><span class="w"> </span><span class="m">06</span>:18:24<span class="w"> </span>GMT<span class="p">;</span><span class="w"> </span><span class="nv">Path</span><span class="o">=</span>/
Strict-Transport-Security:<span class="w"> </span>max-age<span class="o">=</span><span class="m">31536000</span><span class="p">;</span><span class="w"> </span>includeSubDomains<span class="p">;</span>
</code></pre></div>

<blockquote>
<p>Note: The AWS load balancer cookie is used by the load balancer to route a user's
requests to the same application server they used in the previous request.</p>
</blockquote>
<h4>HTTP traffic</h4>
<p>The HTTP response showed that we did not redirect traffic to HTTPS and it also
included the HSTS header, even though the HSTS header is only in the HTTPS
section of the server configuration. Somehow the application server was
responding to HTTP traffic using HTTPS instructions.</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>curl<span class="w"> </span>--head<span class="w"> </span>-X<span class="w"> </span>GET<span class="w"> </span><span class="s2">&quot;http://ona.io/login&quot;</span>
HTTP/1.1<span class="w"> </span><span class="m">200</span><span class="w"> </span>OK
Set-Cookie:<span class="w"> </span><span class="nv">AWSALB</span><span class="o">=</span>ZplUR<span class="p">;</span><span class="w"> </span><span class="nv">Expires</span><span class="o">=</span>Thu,<span class="w"> </span><span class="m">23</span><span class="w"> </span>Mar<span class="w"> </span><span class="m">2017</span><span class="w"> </span><span class="m">06</span>:20:07<span class="w"> </span>GMT<span class="p">;</span><span class="w"> </span><span class="nv">Path</span><span class="o">=</span>/
Strict-Transport-Security:<span class="w"> </span>max-age<span class="o">=</span><span class="m">31536000</span><span class="p">;</span><span class="w"> </span>includeSubDomains<span class="p">;</span>
</code></pre></div>

<h4>What we knew and what we wanted</h4>
<p>Looking at our Target Groups, we didn't have a Target Group for port 80 (HTTP), but we
did have a Target Group for port 443 (HTTPS). We knew that the load balancer, with Target Groups configured for port 443, was
working well. We also knew that HTTP requests via the domain name were going through the
load balancer to the reverse proxy (we use NGINX), but we didn't know why those from the
load balancer to the reverse proxy were failing.</p>
<p>From the response to the HTTP request above, we could tell that the load balancer
was routing port 80 requests to the same Target Group used for port 443, then to the
reverse proxy for it to decide what do with the request.
Moreover, from looking at the reverse proxy logs, we saw that HTTP requests ended up in the
HTTPS logs.</p>
<h2>Solution: just add a rule for port 80. Wrong!</h2>
<p>We knew that the load balancer makes health check requests to the
application servers using the IP address and not the domain name, which seems to be reasonable, yet we were blocking IP address requests as shown below.</p>
<div class="highlight"><pre><span></span><code>server {
    listen 80 default_server;
    server_name  _;
    return 444;
    deny all;
}
</code></pre></div>

<p>We block IP address requests in order to avoid crawlers or malicious actors that target a range of IP addresses, and through this end up placing unnecessary load on our servers. We also don't want our application server to respond to IP address requests, again
to avoid unnecessary load on the application servers. For example, here's a normal crawling request by IP address from
our logs:</p>
<div class="highlight"><pre><span></span><code><span class="mf">180.76.15.155</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">[</span><span class="mf">15</span><span class="o">/</span><span class="n">Mar</span><span class="o">/</span><span class="mf">2017</span><span class="p">:</span><span class="mf">13</span><span class="p">:</span><span class="mf">20</span><span class="p">:</span><span class="mf">43</span><span class="w"> </span><span class="o">+</span><span class="mf">0000</span><span class="err">]</span><span class="w"> </span><span class="s">&quot;GET / HTTP/1.1&quot;</span><span class="w"> </span><span class="mf">301</span><span class="w"> </span><span class="mf">185</span><span class="w"> </span><span class="s">&quot;-&quot;</span><span class="w"> </span><span class="s">&quot;Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)&quot;</span>
</code></pre></div>

<p>With IP address requests being blocked, just adding a Target Group
for port 80 wouldn't work. The health check requests would get denied, and the load balancer would assume the application server is unhealthy on port 80
and not route port 80 traffic at all. An arguably worse position to be in.</p>
<blockquote>
<p>Note: We don't have a rule to block or deny IP address requests to port 443 because
HTTPS requests depend on domain names. This wouldn't be the place we want to
handle this because we'd end up trying to make a firewall out of Nginx.</p>
</blockquote>
<p>What we want is for HTTP traffic to redirect to HTTPS as a final result.
On top of this, we want to use the application server's reverse proxy to
redirect HTTP traffic to HTTPS, and not use the load balancer.
For this to happen, the load balancer has to forward port 80 traffic to the
reverse proxy and the reverse proxy should decide what to do with the
traffic. In this case, we want the reverse proxy to respond with a 301
redirect and send the request to HTTPS.</p>
<p>As a start, we added a Target Group for port 80 traffic and had it expect a
status code 301 permanent redirect.
We then added a listener on the load balancer for the Target Group.
We could now see IP address requests behaving as in the snippet below:</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>curl<span class="w"> </span>--head<span class="w"> </span>-X<span class="w"> </span>GET<span class="w"> </span><span class="s2">&quot;http://35.157.7.224&quot;</span>
curl:<span class="w"> </span><span class="o">(</span><span class="m">52</span><span class="o">)</span><span class="w"> </span>Empty<span class="w"> </span>reply<span class="w"> </span>from<span class="w"> </span>server
</code></pre></div>

<p>This was a result of the load balancer finding the application server unhealthy
on port 80 because its requests were being denied.
To solve this, we had to stop denying IP address requests and instead redirect
them to the corresponding domain name. So our default configuration had to
change to the below, with <code>&lt;nginx_server_name&gt;</code> being the domain name we wish to
expose for that server.</p>
<div class="highlight"><pre><span></span><code><span class="nt">server</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">listen</span><span class="w"> </span><span class="err">80</span><span class="w"> </span><span class="err">default_server</span><span class="p">;</span>
<span class="w">    </span><span class="err">server_name</span><span class="w"> </span><span class="err">_</span><span class="p">;</span>
<span class="w">    </span><span class="err">return</span><span class="w"> </span><span class="err">301</span><span class="w"> </span><span class="n">http</span><span class="p">:</span><span class="o">//&lt;</span><span class="n">nginx_server_name</span><span class="o">&gt;</span><span class="err">$</span><span class="n">request_uri</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Now the health check will find the expected response and deem the server healthy.</p>
<h2>Final and desired result</h2>
<p>Our desired result is to redirect IP address requests to the corresponding domain name and let the configuration for the server handling that domain name handle said requests.
We also make sure not to manipulate the protocol, HTTP to HTTPS, on IP address
requests because they would fail if the reverse proxy doesn't support
HTTPS. This also gives the correct response to crawlers.</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>curl<span class="w"> </span>--head<span class="w"> </span>-X<span class="w"> </span>GET<span class="w"> </span><span class="s2">&quot;http://52.59.26.201&quot;</span>
HTTP/1.1<span class="w"> </span><span class="m">301</span><span class="w"> </span>Moved<span class="w"> </span>Permanently
Location:<span class="w"> </span>http://ona.io/
</code></pre></div>

<p>Which you can see happening on some popular domains:</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>curl<span class="w"> </span>--head<span class="w"> </span>-X<span class="w"> </span>GET<span class="w"> </span><span class="s2">&quot;http://74.125.230.163&quot;</span>
HTTP/1.1<span class="w"> </span><span class="m">301</span><span class="w"> </span>Moved<span class="w"> </span>Permanently
Location:<span class="w"> </span>http://www.google.com/
</code></pre></div>

<p>Name requests also get properly routed to HTTPS using a 301 redirect.</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>curl<span class="w"> </span>--head<span class="w"> </span>-X<span class="w"> </span>GET<span class="w"> </span><span class="s2">&quot;http://ona.io/login&quot;</span>
HTTP/1.1<span class="w"> </span><span class="m">301</span><span class="w"> </span>Moved<span class="w"> </span>Permanently
Location:<span class="w"> </span>https://ona.io/login
</code></pre></div>

<h4>Handling HTTP at the reverse proxy</h4>
<p>We also want NGINX to handle port 80 traffic using recommendations from
<a href="https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/#taxing-rewrites">NGINX Pitfalls and Common Mistakes under Taxing Rewrites</a>. With this we can "effectively avoid doing any capturing or matching at all."</p>
<div class="highlight"><pre><span></span><code><span class="nt">server</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">listen</span><span class="w"> </span><span class="err">80</span><span class="p">;</span>
<span class="w">    </span><span class="n">listen</span><span class="w"> </span><span class="cp">[</span><span class="p">::</span><span class="cp">]</span><span class="p">:</span><span class="mi">80</span><span class="p">;</span>

<span class="w">    </span><span class="err">server_name</span><span class="w"> </span><span class="err">ona.io</span><span class="p">;</span>

<span class="w">    </span><span class="err">return</span><span class="w"> </span><span class="err">301</span><span class="w"> </span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="err">$</span><span class="n">server_name</span><span class="err">$</span><span class="n">request_uri</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h4>Recommendations from the <a href="https://hstspreload.org">HSTS Preload List Submission</a> site</h4>
<p>To double-check that we had fixed our problem with HSTS, we used the <a href="https://hstspreload.org">HSTS Preload List Submission</a> site to validate our configuration. Before we had this result:
<img alt="hsts-preload-not-ok.png" src="/assets/images/2017-03-31/htsts-preload-not-ok.png"></p>
<p>Now we have this:
<img alt="hsts-preload-ok.png" src="/assets/images/2017-03-31/hsts-preload-ok.png"></p>
<h2>Wrapping up</h2>
<p>We started with a broken configuration that put a small subset of HTTP requests into a redirect loop. The users behind these requests likely ended up going to our HTTPS URL and incidentally fixing the HTTP problem, then never following up with us. After digging in, we found that we had misconfigured both our AWS Elastic Load Balancer Target Groups and our reverse proxy rules. This was a problem for our users and for our HSTS configuration. By correcting these configuration problems we have removed the redirect loop and fixed our HSTS configuration.</p>
    </div>
  </article>
    </div>
  </div>

  <footer class="footer">
    <div class="container">
<div class="row">
  <ul class="col-sm-6 list-inline">
      <li class="list-inline-item"><a href="/authors.html">Authors</a></li>
    <li class="list-inline-item"><a href="/archives.html">Archives</a></li>
    <li class="list-inline-item"><a href="/categories.html">Categories</a></li>
      <li class="list-inline-item"><a href="/tags.html">Tags</a></li>
  </ul>
  <p class="col-sm-6 text-sm-right text-muted">
    Generated by <a href="https://github.com/getpelican/pelican" target="_blank">Pelican</a>
    / <a href="https://github.com/nairobilug/pelican-alchemy" target="_blank">&#x2728;</a>
  </p>
</div>    </div>
  </footer>

</body>

</html>